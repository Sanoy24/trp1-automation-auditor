"""
report_generator.py ‚Äî Markdown serializer for AuditReport.

Converts the Pydantic AuditReport model into a structured Markdown file
following the format: Executive Summary ‚Üí Criterion Breakdown ‚Üí Remediation Plan.

The report is written to disk ‚Äî never just printed to console.
"""

from __future__ import annotations

import logging
import os
from pathlib import Path
from typing import Optional

from src.state import AuditReport, CriterionResult

logger = logging.getLogger(__name__)


def _render_criterion(criterion: CriterionResult, index: int) -> str:
    """Render a single criterion section as Markdown."""
    lines = []
    lines.append(f"### {index}. {criterion.dimension_name}")
    lines.append(f"**Criterion ID:** `{criterion.dimension_id}`")
    lines.append(f"**Final Score:** {criterion.final_score}/5")
    lines.append("")

    # Judge opinions table
    lines.append("#### Judge Opinions")
    lines.append("")
    lines.append("| Judge | Score | Key Argument |")
    lines.append("|-------|-------|-------------|")

    for opinion in criterion.judge_opinions:
        # Truncate argument for table readability
        short_arg = opinion.argument[:150].replace("|", "\\|").replace("\n", " ")
        if len(opinion.argument) > 150:
            short_arg += "..."
        lines.append(f"| {opinion.judge} | {opinion.score}/5 | {short_arg} |")

    lines.append("")

    # Full arguments
    lines.append("#### Detailed Arguments")
    lines.append("")
    for opinion in criterion.judge_opinions:
        lines.append(f"**{opinion.judge}** (Score: {opinion.score}/5):")
        lines.append(f"> {opinion.argument}")
        lines.append("")
        if opinion.cited_evidence:
            lines.append(f"*Cited Evidence:* {', '.join(f'`{e}`' for e in opinion.cited_evidence)}")
            lines.append("")

    # Dissent summary (if applicable)
    if criterion.dissent_summary:
        lines.append("#### ‚ö†Ô∏è Dissent Summary")
        lines.append(f"> {criterion.dissent_summary}")
        lines.append("")

    # Remediation
    lines.append("#### Remediation")
    lines.append(criterion.remediation)
    lines.append("")
    lines.append("---")
    lines.append("")

    return "\n".join(lines)


def render_audit_report(report: AuditReport, output_path: str) -> str:
    """Serialize an AuditReport to a structured Markdown file.

    Args:
        report: The finalized AuditReport Pydantic model.
        output_path: File path where the Markdown report will be written.

    Returns:
        The full Markdown content as a string.
    """
    lines = []

    # Header
    lines.append("# üèõÔ∏è Automaton Auditor ‚Äî Audit Report")
    lines.append("")
    lines.append(f"**Repository:** `{report.repo_url}`")
    lines.append(f"**Overall Score:** {report.overall_score}/5.0")
    lines.append("")

    # Score visualization
    filled = int(report.overall_score)
    score_bar = "‚ñà" * filled + "‚ñë" * (5 - filled)
    lines.append(f"**Rating:** {score_bar} ({report.overall_score}/5.0)")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Executive Summary
    lines.append("## Executive Summary")
    lines.append("")
    lines.append(report.executive_summary)
    lines.append("")
    lines.append("---")
    lines.append("")

    # Criteria breakdown
    lines.append("## Criterion Breakdown")
    lines.append("")
    lines.append(f"Total criteria assessed: {len(report.criteria)}")
    lines.append("")

    # Summary table
    lines.append("| # | Criterion | Score | Dissent? |")
    lines.append("|---|-----------|-------|----------|")
    for i, c in enumerate(report.criteria, 1):
        dissent = "‚ö†Ô∏è Yes" if c.dissent_summary else "‚Äî"
        lines.append(f"| {i} | {c.dimension_name} | {c.final_score}/5 | {dissent} |")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Detailed criterion sections
    for i, criterion in enumerate(report.criteria, 1):
        lines.append(_render_criterion(criterion, i))

    # Remediation Plan
    lines.append("## Remediation Plan")
    lines.append("")
    lines.append(report.remediation_plan)
    lines.append("")

    # Footer
    lines.append("---")
    lines.append("*Report generated by the Automaton Auditor Swarm*")

    content = "\n".join(lines)

    # Ensure output directory exists
    output_dir = os.path.dirname(output_path)
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)

    # Write atomically: write to a temporary file then rename into place.
    import tempfile

    tmp_path = f"{output_path}.tmp"
    try:
        with open(tmp_path, "w", encoding="utf-8") as f:
            f.write(content)
        # Atomic replace (works across platforms)
        os.replace(tmp_path, output_path)
        logger.info("Audit report written to %s (%d bytes)", output_path, len(content))
    except KeyboardInterrupt:
        # If user interrupts while writing, ensure temp file is removed and
        # re-raise so callers can handle the KeyboardInterrupt.
        try:
            if os.path.exists(tmp_path):
                os.remove(tmp_path)
        except Exception:
            pass
        raise
    except Exception as exc:
        # Clean up temporary file on error and re-raise
        try:
            if os.path.exists(tmp_path):
                os.remove(tmp_path)
        except Exception:
            pass
        raise

    return content
